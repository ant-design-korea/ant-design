{"version":3,"sources":["docs/blog/getContainer.zh-CN.md?type=text"],"sourcesContent":["\n  import '/home/runner/work/ant-design/ant-design/docs/blog/getContainer.zh-CN.md?watch=parent';\n  export const texts = [{\"value\":\"在网页开发中，我们时常会遇到弹出元素的需求，比如 Select 的下拉框、或者是 Modal 组件。直接将其渲染到当前节点下时，可能会被父节点的 \",\"paraId\":0},{\"value\":\"overflow: hidden\",\"paraId\":0},{\"value\":\" 裁剪掉：\",\"paraId\":0},{\"value\":\"因而在 Ant Design 中，我们默认将其渲染到 \",\"paraId\":1},{\"value\":\"body\",\"paraId\":1},{\"value\":\" 下，但是这又会带来新的问题。由于不在同一个容器下，当用户滚动屏幕时会发现弹出层并未跟随滚动：\",\"paraId\":1},{\"value\":\"为了解决这个问题，我们提供了 \",\"paraId\":2},{\"value\":\"getContainer\",\"paraId\":2},{\"value\":\" 属性，让用户可以自定义渲染的容器。\",\"paraId\":2},{\"value\":\"getContainer\",\"paraId\":2},{\"value\":\" 方法会在组件挂载时调用，返回一个容器节点，组件会通过 \",\"paraId\":2},{\"value\":\"createPortal\",\"paraId\":2},{\"value\":\" 渲染到这个节点下。\",\"paraId\":2},{\"value\":\"// Fake Code. Just for Demo\\nconst PopupWrapper = () => {\\n  const eleRef = React.useRef<HTMLDivElement>(null);\\n\\n  React.useEffect(() => {\\n    // It's much complex with timing in real world. You can view the source for more detail:\\n    // https://github.com/react-component/portal/blob/master/src/Portal.tsx\\n    const container: HTMLElement = getContainer(eleRef.current);\\n\\n    // ...\\n  }, []);\\n\\n  return (\\n    <div ref={eleRef}>\\n      {...}\\n    </div>\\n  );\\n}\\n\",\"paraId\":3},{\"value\":\"// Fake Code. Just for Demo\\nconst defaultGetContainer = () => {\\n  const div = document.createElement('div');\\n  document.body.appendChild(div);\\n  return div;\\n};\\n\\nconst SomeComponent = ({ getContainer = defaultGetContainer }) => (\\n  <PopupWrapper getContainer={getContainer} />\\n);\\n\",\"paraId\":4},{\"value\":\"我们暂时不关注 \",\"paraId\":5},{\"value\":\"getContainer\",\"paraId\":5},{\"value\":\" 需要动态切换挂载节点的需求（其实在过去很长时间它的确也无法切换），仅仅从 React 18 看，它遇到了一些问题。\",\"paraId\":5},{\"value\":\"React 18 中，effect 可能会多次触发。为了防止不经意间破坏开发者的行为，在 \",\"paraId\":6,\"tocIndex\":0},{\"value\":\"StrictMode\",\"paraId\":6,\"tocIndex\":0},{\"value\":\" 下它也做了相应的调整：\",\"paraId\":6,\"tocIndex\":0},{\"value\":\"React mounts the component.\\n\",\"paraId\":7,\"tocIndex\":0},{\"value\":\"Layout effects are created.\",\"paraId\":8,\"tocIndex\":0},{\"value\":\"Effect effects are created.\",\"paraId\":8,\"tocIndex\":0},{\"value\":\"React simulates effects being destroyed on a mounted component.\\n\",\"paraId\":7,\"tocIndex\":0},{\"value\":\"Layout effects are destroyed.\",\"paraId\":9,\"tocIndex\":0},{\"value\":\"Effects are destroyed.\",\"paraId\":9,\"tocIndex\":0},{\"value\":\"React simulates effects being re-created on a mounted component.\\n\",\"paraId\":7,\"tocIndex\":0},{\"value\":\"Layout effects are created\",\"paraId\":10,\"tocIndex\":0},{\"value\":\"Effect setup code runs\",\"paraId\":10,\"tocIndex\":0},{\"value\":\"简单理解就是 StrictMode 下，即便你的 deps 里是空对象，effect 仍然会多次触发。在切换为 React 18 StrictMode 的时候，我们会发现在 HTML 中会成对出现挂载节点，同时前一个是空的：\",\"paraId\":11,\"tocIndex\":0},{\"value\":\"<body>\\n  <div id=\\\"root\\\">...</div>\\n\\n  <!-- Empty -->\\n  <div className=\\\"sample-holder\\\"></div>\\n\\n  <!-- Real in use -->\\n  <div className=\\\"sample-holder\\\">\\n    <div className=\\\"ant-component-wrapper\\\">...</div>\\n  </div>\\n</body>\\n\",\"paraId\":12,\"tocIndex\":0},{\"value\":\"因而我们调整了调用实现，默认的 \",\"paraId\":13,\"tocIndex\":0},{\"value\":\"getContainer\",\"paraId\":13,\"tocIndex\":0},{\"value\":\" 也通过 state 进行管理，确保在 StrictMode 下会清理前一个 effect 生成的节点：\",\"paraId\":13,\"tocIndex\":0},{\"value\":\"// Fake Code. Just for Demo\\nconst SomeComponent = ({ getContainer }) => {\\n  const [myContainer, setMyContainer] = React.useState<HTMLElement | null>(null);\\n\\n  React.useEffect(() => {\\n    if (getContainer) {\\n      setMyContainer(getContainer());\\n      return;\\n    }\\n\\n    const div = document.createElement('div');\\n    document.body.appendChild(div);\\n    setMyContainer(div);\\n\\n    return () => {\\n      document.body.removeChild(div);\\n    };\\n  }, [getContainer]);\\n\\n  return <PopupWrapper getContainer={() => myContainer} />;\\n};\\n\",\"paraId\":14,\"tocIndex\":0},{\"value\":\"将 \",\"paraId\":15,\"tocIndex\":0},{\"value\":\"getContainer\",\"paraId\":15,\"tocIndex\":0},{\"value\":\" 放入 effect 管理后，我们可以更符合 React 生命周期的方式去管理节点，同时也可以在 \",\"paraId\":15,\"tocIndex\":0},{\"value\":\"getContainer\",\"paraId\":15,\"tocIndex\":0},{\"value\":\" 变化时进行清理。从而支持动态改变 \",\"paraId\":15,\"tocIndex\":0},{\"value\":\"getContainer\",\"paraId\":15,\"tocIndex\":0},{\"value\":\" 的场景（虽然我个人比较怀疑这种使用场景的普遍性）。\",\"paraId\":15,\"tocIndex\":0},{\"value\":\"由于修复了 \",\"paraId\":16,\"tocIndex\":1},{\"value\":\"getContainer\",\"paraId\":16,\"tocIndex\":1},{\"value\":\" 不支持动态改变的问题，它也引入了一个潜在的 breaking change。开发者如果自定义 \",\"paraId\":16,\"tocIndex\":1},{\"value\":\"getContainer\",\"paraId\":16,\"tocIndex\":1},{\"value\":\" 每次都是创建新的 DOM 节点时，它就会因为 effect 不断执行，导致节点不断创建而死循环。如果你使用了这种方式并且遇到了问题，需要注意检查。\",\"paraId\":16,\"tocIndex\":1}];\n  "],"names":[],"mappings":"qOAEe,6CAAA,QADN,YACA,IAAM,EAAQ,CAAC,CAAC,MAAQ,yWAA4E,OAAS,CAAC,EAAE,CAAC,MAAQ,mBAAmB,OAAS,CAAC,EAAE,CAAC,MAAQ,4BAAQ,OAAS,CAAC,EAAE,CAAC,MAAQ,oGAA8B,OAAS,CAAC,EAAE,CAAC,MAAQ,OAAO,OAAS,CAAC,EAAE,CAAC,MAAQ,wRAAkD,OAAS,CAAC,EAAE,CAAC,MAAQ,wFAAkB,OAAS,CAAC,EAAE,CAAC,MAAQ,eAAe,OAAS,CAAC,EAAE,CAAC,MAAQ,0GAAqB,OAAS,CAAC,EAAE,CAAC,MAAQ,eAAe,OAAS,CAAC,EAAE,CAAC,MAAQ,iKAA+B,OAAS,CAAC,EAAE,CAAC,MAAQ,eAAe,OAAS,CAAC,EAAE,CAAC,MAAQ,0DAAa,OAAS,CAAC,EAAE,CAAC,MAAQ,+dAA+d,OAAS,CAAC,EAAE,CAAC,MAAQ,oSAAoS,OAAS,CAAC,EAAE,CAAC,MAAQ,8CAAW,OAAS,CAAC,EAAE,CAAC,MAAQ,eAAe,OAAS,CAAC,EAAE,CAAC,MAAQ,wSAA6D,OAAS,CAAC,EAAE,CAAC,MAAQ,4LAAgD,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,aAAa,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,sEAAe,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,gCAAgC,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,8BAA8B,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,8BAA8B,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,oEAAoE,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,gCAAgC,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,yBAAyB,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,qEAAqE,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,6BAA6B,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,yBAAyB,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,+ZAAmH,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,0OAAkP,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,8FAAmB,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,eAAe,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,+KAAuD,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,qiBAAqiB,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,UAAK,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,eAAe,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,oNAAoD,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,eAAe,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,qGAAqB,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,eAAe,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,0JAA6B,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,kCAAS,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,eAAe,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,yMAAmD,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,eAAe,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,yXAA6E,OAAS,GAAG,SAAW,CAAC,EAAE"}