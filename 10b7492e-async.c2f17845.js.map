{"version":3,"sources":["docs/blog/suspense.zh-CN.md?type=text"],"sourcesContent":["\n  import '/home/runner/work/ant-design/ant-design/docs/blog/suspense.zh-CN.md?watch=parent';\n  export const texts = [{\"value\":\"我们知道，React 18 提供了一个专门为 CSS-IN-JS 使用的 \",\"paraId\":0},{\"value\":\"useInsertionEffect\",\"paraId\":0},{\"value\":\" hooks，它会比 \",\"paraId\":0},{\"value\":\"useLayoutEffect\",\"paraId\":0},{\"value\":\" 拥有更快的时序优先级，从而保证不会因为书写顺序而影响调用顺序的问题：\",\"paraId\":0},{\"value\":\"useLayoutEffect(() => {\\n  console.log('layout effect');\\n}, []);\\n\\nuseInsertionEffect(() => {\\n  console.log('insertion effect');\\n}, []);\\n\\n// Console:\\n// - insertion effect\\n// - layout effect\\n\",\"paraId\":1},{\"value\":\"在早期 \",\"paraId\":2},{\"value\":\"@ant-design/cssinjs\",\"paraId\":2},{\"value\":\" 实现中，由于需要兼容 React 17 版本，我们并没有选择 \",\"paraId\":2},{\"value\":\"useInsertionEffect\",\"paraId\":2},{\"value\":\"，而是通过在 render 阶段添加样式的方式来模拟提前插入的效果：\",\"paraId\":2},{\"value\":\"// pseudocode. Not used in real world\\nfunction useStyleInsertion(hash: string, counter: Record<string, number>) {\\n  useMemo(() => {\\n    if (!counter[hash]) {\\n      // Insert only when current style not inserted\\n    }\\n\\n    counter[hash] += 1;\\n  }, [hash]);\\n\\n  useEffect(\\n    () => () => {\\n      counter[hash] -= 1;\\n\\n      if (!counter[hash]) {\\n        // Remove if set to clear on destroy\\n      }\\n    },\\n    [hash],\\n  );\\n}\\n\",\"paraId\":3},{\"value\":\"以上代码会对使用样式进行统计，如果发现当前样式没有被插入过，就会在 render 阶段插入样式，否则就不会插入。同样的，如果发现当前样式配置了未使用时卸载，则会在 effect 确认计数后清除。此外，还有一套类似的代码会监听 token 的变化，当存在多份 token 时会对不再使用的 token 对应的所有样式 \",\"paraId\":4},{\"value\":\"<style />\",\"paraId\":4},{\"value\":\" 进行清理，以避免过多的主题切换导致的内存泄漏。\",\"paraId\":4},{\"value\":\"这段代码在 React 17 可以完美运行，在 React 18 的 StrictMode 下也运行的十分正常。\",\"paraId\":5},{\"value\":\"counter\",\"paraId\":5},{\"value\":\" 总是成对出现与消失。但是它在 Suspense 下，就会有概率出现问题了。\",\"paraId\":5},{\"value\":\"React 18 的 StrictMode 和 \",\"paraId\":6,\"tocIndex\":0},{\"value\":\"React 17\",\"paraId\":6,\"tocIndex\":0},{\"value\":\"不同的是，它会在各个阶段进行多次调用，从而确保开发者对 Effect 进行了清理：\",\"paraId\":6,\"tocIndex\":0},{\"value\":\"const My = () => {\\n  console.log('render');\\n\\n  useMemo(() => {\\n    console.log('memo');\\n  }, []);\\n\\n  useEffect(() => {\\n    console.log('effect');\\n\\n    return () => {\\n      console.log('effect cleanup');\\n    };\\n  }, []);\\n};\\n\\n<StrictMode>\\n  <My />\\n</StrictMode>;\\n\\n// Console:\\n// - render\\n// - memo\\n// - render\\n// - memo\\n// - effect\\n// - effect cleanup\\n// - effect\\n\",\"paraId\":7,\"tocIndex\":0},{\"value\":\"从上面的例子可以知道，\",\"paraId\":8,\"tocIndex\":0},{\"value\":\"counter\",\"paraId\":8,\"tocIndex\":0},{\"value\":\" 在 StrictMode 虽然会累加，但是最终会是正确的值（即每个组件只计算 1 次统计）：\",\"paraId\":8,\"tocIndex\":0},{\"value\":\"memo: 1\",\"paraId\":9,\"tocIndex\":0},{\"value\":\"memo: 2\",\"paraId\":9,\"tocIndex\":0},{\"value\":\"effect cleanup: 1\",\"paraId\":9,\"tocIndex\":0},{\"value\":\"但是 StrictMode 只是对 Suspense 的模拟。在真实场景下，执行次数并不会保证成对出现。\",\"paraId\":10,\"tocIndex\":0},{\"value\":\"我们使用 \",\"paraId\":11,\"tocIndex\":1},{\"value\":\"umi\",\"paraId\":11,\"tocIndex\":1},{\"value\":\" 进行站点开发，它默认按页拆包、按需加载。通过 Suspense 的方式在加载过程中显示 loading 状态：\",\"paraId\":11,\"tocIndex\":1},{\"value\":\"<BrowserRoutes>\\n  <Routs>\\n    <Suspense fallback={<Loading />} />\\n  </Routs>\\n</BrowserRoutes>\\n\",\"paraId\":12,\"tocIndex\":1},{\"value\":\"在页面切换时，偶发出现页面往复切换时部分样式丢失的情况：\",\"paraId\":13,\"tocIndex\":1},{\"value\":\"其中 Page 1 丢失部分的样式为 Page 1 独有的样式（通过 ConfigProvider 定制了一些 token），而 Page 2 的样式则为 Page 1 与 Page 2 通用的样式。\",\"paraId\":14,\"tocIndex\":1},{\"value\":\"在我们最初介绍的样式管理逻辑可以明白，Page 1 由于为独立 token 对应的样式，因而在 Page 2 渲染时会被清理掉所有的对应 token 的样式 \",\"paraId\":15,\"tocIndex\":1},{\"value\":\"<style />\",\"paraId\":15,\"tocIndex\":1},{\"value\":\"。这看起来是符合预期的，那么问题就出在了切回 Page 1 时样式没有被重新插入。\",\"paraId\":15,\"tocIndex\":1},{\"value\":\"在经过一系列断点后，我们发现这个问题出现在计数器不同步之上。由于 Suspense 的特性，它会在加载过程中多次调用组件，所以组件样式注册的时机也会被调用多次。而由于我们的计数器是在 render 阶段进行的，所以在 Suspense 下，计数器会被多次调用，从而导致计数器的值不正确：\",\"paraId\":16,\"tocIndex\":2},{\"value\":\"render: 0\",\"paraId\":17,\"tocIndex\":2},{\"value\":\"useMemo: 1\",\"paraId\":17,\"tocIndex\":2},{\"value\":\"render: 1\",\"paraId\":17,\"tocIndex\":2},{\"value\":\"useMemo: 2\",\"paraId\":17,\"tocIndex\":2},{\"value\":\"effect: 2\",\"paraId\":17,\"tocIndex\":2},{\"value\":\"不像 StrictMode，effect 并没有再次执行，所以 effect cleanup 也不会执行\",\"paraId\":17,\"tocIndex\":2},{\"value\":\"计数器不同步导致 token 层面已经认为样式已经没有再使用所以进行了批量清理，而在组件样式层面则认为还有其他组件在使用，所以当重新进入 Page 1 时并不会重新插入样式。\",\"paraId\":18,\"tocIndex\":2},{\"value\":\"显而易见，Suspense 由于其特性，我们不能通过 \",\"paraId\":19,\"tocIndex\":3},{\"value\":\"useMemo\",\"paraId\":19,\"tocIndex\":3},{\"value\":\" 来做计数器，它不会和 \",\"paraId\":19,\"tocIndex\":3},{\"value\":\"useEffect\",\"paraId\":19,\"tocIndex\":3},{\"value\":\" 成对出现。所以我们考虑需要使用 \",\"paraId\":19,\"tocIndex\":3},{\"value\":\"useInsertionEffect\",\"paraId\":19,\"tocIndex\":3},{\"value\":\" 来进行样式的插入：\",\"paraId\":19,\"tocIndex\":3},{\"value\":\"// pseudocode. Not used in real world\\nuseInsertionEffect(() => {\\n  if (!counter[hash]) {\\n    // Insert only when current style not inserted\\n  }\\n  counter[hash] += 1;\\n\\n  return () => {\\n    counter[hash] -= 1;\\n\\n    if (!counter[hash]) {\\n      // Remove if set to clear on destroy\\n    }\\n  };\\n}, [hash]);\\n\",\"paraId\":20,\"tocIndex\":3},{\"value\":\"而对于 React 17 版本，则降级为 \",\"paraId\":21,\"tocIndex\":3},{\"value\":\"useLayoutEffect\",\"paraId\":21,\"tocIndex\":3},{\"value\":\"：\",\"paraId\":21,\"tocIndex\":3},{\"value\":\"const useMergedInsertionEffect = useInsertionEffect || useLayoutEffect;\\n\\nuseMergedInsertionEffect(() => {\\n  // Same as above\\n}, [hash]);\\n\",\"paraId\":22,\"tocIndex\":3},{\"value\":\"经过这样的修改后，我们发现 React 17 的 CI 挂了。在检查后，发现 \",\"paraId\":23,\"tocIndex\":3},{\"value\":\"useLayoutEffect\",\"paraId\":23,\"tocIndex\":3},{\"value\":\" 就会出现时序问题：\",\"paraId\":23,\"tocIndex\":3},{\"value\":\"// Some logic measure DOM size\\nuseLayoutEffect(() => {\\n  // This is not correct since style is not applied\\n  const { clientHeight } = nodeRef.current;\\n}, []);\\n\\n// Inject style\\nuseLayoutEffect(() => {\\n  // ...\\n}, [hash]);\\n\",\"paraId\":24,\"tocIndex\":3},{\"value\":\"测量的 \",\"paraId\":25,\"tocIndex\":3},{\"value\":\"useLayoutEffect\",\"paraId\":25,\"tocIndex\":3},{\"value\":\" 先于注入样式执行，导致获取了错误的尺寸信息。也可以预测到这会对开发者产生影响。因而我们退而求其次，在 React 17 版本时会降级为原先的 \",\"paraId\":25,\"tocIndex\":3},{\"value\":\"useMemo\",\"paraId\":25,\"tocIndex\":3},{\"value\":\" 插入。\",\"paraId\":25,\"tocIndex\":3},{\"value\":\"在上面的方案中，我们启用了 \",\"paraId\":26,\"tocIndex\":4},{\"value\":\"useInsertionEffect\",\"paraId\":26,\"tocIndex\":4},{\"value\":\" 从而完美解决了渲染问题。但在 React 17 及以下版本，我们仍然会在 render 阶段插入样式，但是会在 effect 阶段让引用计数加一。但是这带来了新的问题，我们来看一段代码 (\",\"paraId\":26,\"tocIndex\":4},{\"value\":\"CodeSandbox\",\"paraId\":26,\"tocIndex\":4},{\"value\":\")：\",\"paraId\":26,\"tocIndex\":4},{\"value\":\"import React from 'react';\\n\\nconst A = () => {\\n  React.useMemo(() => {\\n    console.log('A render');\\n  }, []);\\n\\n  React.useEffect(() => {\\n    console.log('A mounted');\\n    return () => {\\n      console.log('A unmounted');\\n    };\\n  }, []);\\n\\n  return <div>A</div>;\\n};\\n\\nconst B = () => {\\n  React.useMemo(() => {\\n    console.log('B render');\\n  }, []);\\n\\n  React.useEffect(() => {\\n    console.log('B mounted');\\n    return () => {\\n      console.log('B unmounted');\\n    };\\n  }, []);\\n\\n  return <div>B</div>;\\n};\\n\\nexport default function App() {\\n  const [show, setShow] = React.useState(true);\\n\\n  const toggle = () => {\\n    setShow((prev) => !prev);\\n  };\\n\\n  return (\\n    <div>\\n      <button onClick={toggle}>toggle</button>\\n      <div>{show ? <A /> : <B />}</div>\\n    </div>\\n  );\\n}\\n\",\"paraId\":27,\"tocIndex\":4},{\"value\":\"在这段代码（严格模式）中，点击按钮会切换 A 与 B 的渲染。那么从 A 切换到 B 时，顺序会是什么样的呢？答案是:\",\"paraId\":28,\"tocIndex\":4},{\"value\":\"B render\\nB render\\nA unmounted\\nB mounted\\nB unmounted\\nB mounted\\n\",\"paraId\":29,\"tocIndex\":4},{\"value\":\"可以看到新组件的渲染是在旧组件的卸载回调之前的。还记得 cssinjs 在 React 17 一下的处理逻辑吗？我们来标记一下：\",\"paraId\":30,\"tocIndex\":4},{\"value\":\"B render      // 写入 cache，插入样式\\nB render      // 写入 cache，插入样式（虽然是重复的，但是有缓存，不会有冗余）\\nA unmounted   // **引用计数减一** （此时原本的计数是 1，执行后变为 0，触发了样式卸载）\\nB mounted     // 引用计数加一 （此时计数是 1，但是样式已经被 A 连带卸载）\\nB unmounted   // 引用计数减一\\nB mounted     // 引用计数加一\\n\",\"paraId\":31,\"tocIndex\":4},{\"value\":\"这样就可以发现，当 A 与 B 共用一段样式时，由于计数没有及时更新，导致样式先被卸载了，后续也并没有触发插入逻辑，所以依然会导致丢失。\",\"paraId\":32,\"tocIndex\":4},{\"value\":\"解决方案也很简单，当计数从 0 变为 1 时，重新插入样式即可。\",\"paraId\":33,\"tocIndex\":4},{\"value\":\"Suspense 在带来渲染能力提升的同时也让时序变得十分重要，仅仅对 StrictMode 进行处理并不是一个最优的方式。针对不同的 React 版本使用不同的逻辑其实会存在不同版本之间的时序问题，\",\"paraId\":34,\"tocIndex\":5},{\"value\":\"render\",\"paraId\":34,\"tocIndex\":5},{\"value\":\" 会从父节点到子节点依次触发，而 \",\"paraId\":34,\"tocIndex\":5},{\"value\":\"useInsertionEffect\",\"paraId\":34,\"tocIndex\":5},{\"value\":\" 则相反。不过从 antd 角度来说，组件样式之间相互独立，所以这种时序问题并不会对我们产生影响。\",\"paraId\":34,\"tocIndex\":5}];\n  "],"names":[],"mappings":"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"}