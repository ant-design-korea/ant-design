{"version":3,"sources":["docs/blog/virtual-table.zh-CN.md?type=text"],"sourcesContent":["\n  import '/home/runner/work/ant-design/ant-design/docs/blog/virtual-table.zh-CN.md?watch=parent';\n  export const texts = [{\"value\":\"在 v4 时期，我们为 Table 添加了一个自定义 \",\"paraId\":0,\"tocIndex\":0},{\"value\":\"components\",\"paraId\":0,\"tocIndex\":0},{\"value\":\" 的示例，通过 \",\"paraId\":0,\"tocIndex\":0},{\"value\":\"components.body\",\"paraId\":0,\"tocIndex\":0},{\"value\":\" 替换默认的 \",\"paraId\":0,\"tocIndex\":0},{\"value\":\"<tbody>\",\"paraId\":0,\"tocIndex\":0},{\"value\":\"，实现虚拟滚动的效果。但是很多开发者反馈 Demo 中的虚拟表格有很多功能无法实现。例如 固定列、合并行列、展开行 等等。\",\"paraId\":0,\"tocIndex\":0},{\"value\":\"所以在 v5 中，我们提出了 \",\"paraId\":1,\"tocIndex\":0},{\"value\":\"[RFC] StaticTable for fast perf & virtual scroll support\",\"paraId\":1,\"tocIndex\":0},{\"value\":\"。该 RFC 期望提供一个高性能的 Table.StaticTable，它会默认支持虚拟滚动。但是随着开发进行，我们最终决定 StaticTable 在底层 \",\"paraId\":1,\"tocIndex\":0},{\"value\":\"rc-table\",\"paraId\":1,\"tocIndex\":0},{\"value\":\" 上实现，而在 antd 侧则只需要通过 \",\"paraId\":1,\"tocIndex\":0},{\"value\":\"<Table virtual />\",\"paraId\":1,\"tocIndex\":0},{\"value\":\" 即可开启。\",\"paraId\":1,\"tocIndex\":0},{\"value\":\"Table 通过 \",\"paraId\":2,\"tocIndex\":1},{\"value\":\"virtual\",\"paraId\":2,\"tocIndex\":1},{\"value\":\" 属性即可开启虚拟滚动能力。同时，原 Table 的功能都能正常使用：\",\"paraId\":2,\"tocIndex\":1},{\"value\":\"<Table virtual scroll={{ x: 2000, y: 500 }} {...otherProps} />\\n\",\"paraId\":3,\"tocIndex\":1},{\"value\":\"你可以直接访问 \",\"paraId\":4,\"tocIndex\":4},{\"value\":\"虚拟列表\",\"paraId\":5,\"tocIndex\":4},{\"value\":\" 示例进行体验。\",\"paraId\":4,\"tocIndex\":4},{\"value\":\"antd 的 Table 底层使用了 \",\"paraId\":6,\"tocIndex\":5},{\"value\":\"rc-table\",\"paraId\":6,\"tocIndex\":5},{\"value\":\" 组件，我们的虚拟滚动功能也是复用了上文提到的 \",\"paraId\":6,\"tocIndex\":5},{\"value\":\"components\",\"paraId\":6,\"tocIndex\":5},{\"value\":\" 属性。将中间的 \",\"paraId\":6,\"tocIndex\":5},{\"value\":\"<tbody>\",\"paraId\":6,\"tocIndex\":5},{\"value\":\" 替换为 \",\"paraId\":6,\"tocIndex\":5},{\"value\":\"rc-virtual-list\",\"paraId\":6,\"tocIndex\":5},{\"value\":\"，该组件广泛应用于 antd 的各个虚拟滚动场景中。例如 Select、Tree 都可以见到它的身影。而 \",\"paraId\":6,\"tocIndex\":5},{\"value\":\"rc-virtual-list\",\"paraId\":6,\"tocIndex\":5},{\"value\":\" 本身并不支持横向滚动能力，因而我们在这次改造中，也为其添加了横向滚动的支持。\",\"paraId\":6,\"tocIndex\":5},{\"value\":\"在 v4 时期，我们便将 Table 的固定列改造成了 \",\"paraId\":7,\"tocIndex\":6},{\"value\":\"position: sticky\",\"paraId\":7,\"tocIndex\":6},{\"value\":\" 实现。该 CSS 允许你在滚动时，将元素固定在某个位置。从而避免 v3 时期需要额外渲染一份 Table 用于实现固定位置的效果：\",\"paraId\":7,\"tocIndex\":6},{\"value\":\"对于叠加固定，只需要配置不同的偏移量即可：\",\"paraId\":8,\"tocIndex\":6},{\"value\":\"在虚拟滚动中，我们同样可以利用该特性。直接复用 \",\"paraId\":9,\"tocIndex\":6},{\"value\":\"sticky\",\"paraId\":9,\"tocIndex\":6},{\"value\":\" 样式，即可实现固定列的效果。而 \",\"paraId\":9,\"tocIndex\":6},{\"value\":\"rc-virtual-list\",\"paraId\":9,\"tocIndex\":6},{\"value\":\" 需要付出的仅仅是提供横向滚动，而不需要关心固定列的实现。\",\"paraId\":9,\"tocIndex\":6},{\"value\":\"在 \",\"paraId\":10,\"tocIndex\":7},{\"value\":\"rc-table\",\"paraId\":10,\"tocIndex\":7},{\"value\":\" 中，我们会将 \",\"paraId\":10,\"tocIndex\":7},{\"value\":\"dataSource\",\"paraId\":10,\"tocIndex\":7},{\"value\":\" 通过 \",\"paraId\":10,\"tocIndex\":7},{\"value\":\"useFlattenRecords\",\"paraId\":10,\"tocIndex\":7},{\"value\":\" 将树状结构打平，从而支持开发者自定义的虚拟滚动能力。感谢 \",\"paraId\":10,\"tocIndex\":7},{\"value\":\"@crawler-django\",\"paraId\":10,\"tocIndex\":7},{\"value\":\" 当年的贡献，因而我们这次并不需要再实现一次打平逻辑。\",\"paraId\":10,\"tocIndex\":7},{\"value\":\"但是在测试时，我们发现一个奇怪的现象。表格在首次、再次渲染时，会有非常大的卡顿。在进行断点时，它来自于 \",\"paraId\":11,\"tocIndex\":7},{\"value\":\"useFlattenRecords\",\"paraId\":11,\"tocIndex\":7},{\"value\":\" hooks。而测试的代码本身并没有使用可展开树的功能，于是我们对其进行了排查。发现在 \",\"paraId\":11,\"tocIndex\":7},{\"value\":\"useFlattenRecords\",\"paraId\":11,\"tocIndex\":7},{\"value\":\" 中，存在大量的 GC 操作。而这些操作是由于一段不起眼的代码引起的：\",\"paraId\":11,\"tocIndex\":7},{\"value\":\"// Fake code. Not used in real world\\nfunction flatten<T extends { children?: T[] }>(data: T[] = []) {\\n  let tmpList: T[] = [];\\n\\n  for (let i = 0; i < data.length; i += 1) {\\n    const record = data[i];\\n    tmpList = [...tmpList, record, ...flatten(record.children)];\\n  }\\n\\n  return tmpList;\\n}\\n\",\"paraId\":12,\"tocIndex\":7},{\"value\":\"在遍历过程中，虽然 \",\"paraId\":13,\"tocIndex\":7},{\"value\":\"children\",\"paraId\":13,\"tocIndex\":7},{\"value\":\" 为空只会进入一次递归。但是在循环每个 Record 时都会创建一次临时的空数组。但是当 \",\"paraId\":13,\"tocIndex\":7},{\"value\":\"dataSource\",\"paraId\":13,\"tocIndex\":7},{\"value\":\" 数据巨大时，它们会不断触发 GC 清理这些临时数组。因而我们通过改造添加逻辑以避免不必要的消耗：\",\"paraId\":13,\"tocIndex\":7},{\"value\":\"// Fake code. Not used in real world\\nfunction flatten<T extends { children?: T[] }>(data: T[] = [], list: T[] = []) {\\n  for (let i = 0; i < data.length; i += 1) {\\n    const record = data[i];\\n    list.push(record);\\n    flatten(record.children, list);\\n  }\\n\\n  return list;\\n}\\n\",\"paraId\":14,\"tocIndex\":7},{\"value\":\"如果你对 Table 的实现有所了解，那么你会知道行列合并是通过 \",\"paraId\":15,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":15,\"tocIndex\":8},{\"value\":\" 和 \",\"paraId\":15,\"tocIndex\":8},{\"value\":\"colSpan\",\"paraId\":15,\"tocIndex\":8},{\"value\":\" 实现的。而在虚拟滚动中，由于并不是所有节点都是渲染，所以会出现需要渲染的行列并不存在的情况：\",\"paraId\":15,\"tocIndex\":8},{\"value\":\"为了渲染该项内容，我们就需要计算出当前屏幕区域内的所有 Record 相关的 \",\"paraId\":16,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":16,\"tocIndex\":8},{\"value\":\" 和 \",\"paraId\":16,\"tocIndex\":8},{\"value\":\"colSpan\",\"paraId\":16,\"tocIndex\":8},{\"value\":\"。而这个计算过程是非常复杂的，我们需要遍历所有的 Record，计算出每个 Record 的 \",\"paraId\":16,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":16,\"tocIndex\":8},{\"value\":\" 和 \",\"paraId\":16,\"tocIndex\":8},{\"value\":\"colSpan\",\"paraId\":16,\"tocIndex\":8},{\"value\":\"。显然这是一个非常耗时的操作，而且当 \",\"paraId\":16,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":16,\"tocIndex\":8},{\"value\":\" 数据距离可见区域过远时，它需要额外渲染的内容量也会非常大：\",\"paraId\":16,\"tocIndex\":8},{\"value\":\"对于 \",\"paraId\":17,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":17,\"tocIndex\":8},{\"value\":\"，你可能会想到我们是否可以提前把 \",\"paraId\":17,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":17,\"tocIndex\":8},{\"value\":\" 计算好，然后在滚动时获取这些数据。这其实是不行的，行列数据由 \",\"paraId\":17,\"tocIndex\":8},{\"value\":\"onCell\",\"paraId\":17,\"tocIndex\":8},{\"value\":\" 提供，而在父节点渲染时都全部计算一次 \",\"paraId\":17,\"tocIndex\":8},{\"value\":\"onCell\",\"paraId\":17,\"tocIndex\":8},{\"value\":\" 会产生巨量的性能损耗：\",\"paraId\":17,\"tocIndex\":8},{\"value\":\"const Demo = () => {\\n  const [spanCount, setSpanCount] = useState(3);\\n\\n  const columns = [\\n    {\\n      dataIndex: 'group',\\n      onCell: (_, index) => ({\\n        rowSpan: index % spanCount === 0 ? spanCount : 0,\\n      }),\\n    },\\n  ];\\n\\n  // WOW!\\n  React.useEffect(() => {\\n    setSpanCount(5);\\n  }, []);\\n\\n  return <Table columns={columns} {...props} />;\\n};\\n\",\"paraId\":18,\"tocIndex\":8},{\"value\":\"此外，即便我们统计了 \",\"paraId\":19,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":19,\"tocIndex\":8},{\"value\":\" 的数据，并且将屏幕外的行也进行渲染仍然不够。它可能会出现 \",\"paraId\":19,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":19,\"tocIndex\":8},{\"value\":\" 交替的情况：\",\"paraId\":19,\"tocIndex\":8},{\"value\":\"假设出现最糟的情况，所有的行都和其他的行有 \",\"paraId\":20,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":20,\"tocIndex\":8},{\"value\":\"，那么我们需要渲染的内容量将会是整个 \",\"paraId\":20,\"tocIndex\":8},{\"value\":\"dataSource\",\"paraId\":20,\"tocIndex\":8},{\"value\":\"。即虚拟滚动不再虚拟。因而，我们需要对其进行裁剪，只渲染可见区域内的 \",\"paraId\":20,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":20,\"tocIndex\":8},{\"value\":\"，而将屏幕外的无关部分去除：\",\"paraId\":20,\"tocIndex\":8},{\"value\":\"所以，反向思考。我们只需要从可见区域出发。然后向上、向下获取被 \",\"paraId\":21,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":21,\"tocIndex\":8},{\"value\":\" 影响到的 Record。然后仅对提供 \",\"paraId\":21,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":21,\"tocIndex\":8},{\"value\":\" 的 \",\"paraId\":21,\"tocIndex\":8},{\"value\":\"cell\",\"paraId\":21,\"tocIndex\":8},{\"value\":\" 进行渲染即可：\",\"paraId\":21,\"tocIndex\":8},{\"value\":\"rc-virtual-list\",\"paraId\":22,\"tocIndex\":8},{\"value\":\" 提供了 \",\"paraId\":22,\"tocIndex\":8},{\"value\":\"extraRender\",\"paraId\":22,\"tocIndex\":8},{\"value\":\" 方法，它会提供当前虚拟滚动中所渲染的行号。我们只需要对这个范围内的 Record 执行一次 \",\"paraId\":22,\"tocIndex\":8},{\"value\":\"onCell\",\"paraId\":22,\"tocIndex\":8},{\"value\":\" 获取每个 \",\"paraId\":22,\"tocIndex\":8},{\"value\":\"cell\",\"paraId\":22,\"tocIndex\":8},{\"value\":\" 的 \",\"paraId\":22,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":22,\"tocIndex\":8},{\"value\":\" 和 \",\"paraId\":22,\"tocIndex\":8},{\"value\":\"colSpan\",\"paraId\":22,\"tocIndex\":8},{\"value\":\" 信息。既可以知道当前行是否存在对外的 \",\"paraId\":22,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":22,\"tocIndex\":8},{\"value\":\" 依赖：\",\"paraId\":22,\"tocIndex\":8},{\"value\":\"// Fake code. Not used in real world\\nconst extraRender = ({ start, end }) => {\\n  // Start record\\n  const startRecord = flattenData[start];\\n  columns.forEach((col) => {\\n    // `rowSpan` === 0 means upper record has `rowSpan`\\n    const { rowSpan } = col.onCell(startRecord, start);\\n  });\\n\\n  // End record\\n  const endRecord = flattenData[end];\\n  columns.forEach((col) => {\\n    // `rowSpan` > 1 means it should extend to next records\\n    const { rowSpan } = col.onCell(endRecord, end);\\n  });\\n};\\n\",\"paraId\":23,\"tocIndex\":8},{\"value\":\"需要注意的是，在实际收集过程中，我们会将整个范围有 \",\"paraId\":24,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":24,\"tocIndex\":8},{\"value\":\" 的 \",\"paraId\":24,\"tocIndex\":8},{\"value\":\"cell\",\"paraId\":24,\"tocIndex\":8},{\"value\":\" 都记录下来而不仅仅是头尾的 Record。然后通过 \",\"paraId\":24,\"tocIndex\":8},{\"value\":\"extraRender\",\"paraId\":24,\"tocIndex\":8},{\"value\":\" 方法将这些 \",\"paraId\":24,\"tocIndex\":8},{\"value\":\"cell\",\"paraId\":24,\"tocIndex\":8},{\"value\":\" 渲染出来（而原本的 Record 对于被 \",\"paraId\":24,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":24,\"tocIndex\":8},{\"value\":\" 影响到的 \",\"paraId\":24,\"tocIndex\":8},{\"value\":\"cell\",\"paraId\":24,\"tocIndex\":8},{\"value\":\" 则跳过渲染）。这样就可以保证 \",\"paraId\":24,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":24,\"tocIndex\":8},{\"value\":\" 的正确性了。\",\"paraId\":24,\"tocIndex\":8},{\"value\":\"当然，这种实现是基于 \",\"paraId\":25,\"tocIndex\":8},{\"value\":\"rowSpan > 1\",\"paraId\":25,\"tocIndex\":8},{\"value\":\" 和 \",\"paraId\":25,\"tocIndex\":8},{\"value\":\"rowSpan = 0\",\"paraId\":25,\"tocIndex\":8},{\"value\":\" 会匹配出现的假设。它不支持 \",\"paraId\":25,\"tocIndex\":8},{\"value\":\"rowSpan\",\"paraId\":25,\"tocIndex\":8},{\"value\":\" 用于挤压至下层的情况，但是对于数据表格而言，这已经足够了。\",\"paraId\":25,\"tocIndex\":8},{\"value\":\"虚拟滚动是一个非常复杂的功能，它需要考虑的因素非常多。但是我们相信花费这些精力是值得的，开发者不用再在功能和性能之间做取舍，而是可以同时拥有两者。\",\"paraId\":26,\"tocIndex\":9},{\"value\":\"以上。\",\"paraId\":27,\"tocIndex\":9}];\n  "],"names":[],"mappings":"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"}